#!/usr/bin/env bun
/**
 * Visual Test Reporter for GitHub Actions
 *
 * Reads visual test failures from JSON file and posts them as a PR comment.
 * This script is designed to run in CI after tests complete.
 *
 * Usage:
 *   bun run scripts/visual-test-reporter.ts
 *
 * Environment Variables:
 *   GITHUB_TOKEN - GitHub token for posting comments
 *   GITHUB_REPOSITORY - Repository in format "owner/repo"
 *   PR_NUMBER - PR number to post comment to
 */

import { existsSync, readFileSync } from "fs";

interface VisualFailure {
	testName: string;
	diffPath: string;
	theme: string;
}

/**
 * Reads visual test failures from JSON file
 */
function readFailuresFromJSON(jsonPath: string): VisualFailure[] {
	if (!existsSync(jsonPath)) {
		console.log(`‚ÑπÔ∏è  No visual test failures file found at ${jsonPath}`);
		return [];
	}

	try {
		const content = readFileSync(jsonPath, "utf-8");
		const failures: VisualFailure[] = JSON.parse(content);
		return failures;
	} catch (error) {
		console.error(`‚ùå Failed to read failures JSON: ${error}`);
		return [];
	}
}

/**
 * Generates a GitHub comment with visual test failures
 */
function generateMarkdownComment(failures: VisualFailure[]): string {
	if (failures.length === 0) {
		return "‚úÖ All visual tests passed!";
	}

	let comment = `## ‚ö†Ô∏è Visual Test Failures\n\n`;
	comment += `Found ${failures.length} visual difference(s):\n\n`;

	// Group failures by test name
	const groupedFailures = new Map<string, VisualFailure[]>();
	for (const failure of failures) {
		const existing = groupedFailures.get(failure.testName) || [];
		existing.push(failure);
		groupedFailures.set(failure.testName, existing);
	}

	for (const [testName, testFailures] of groupedFailures.entries()) {
		comment += `### ${testName}\n\n`;

		for (const failure of testFailures) {
			comment += `**Theme:** ${failure.theme}\n\n`;

			// Read and encode the image as base64
			try {
				const imageData = readFileSync(failure.diffPath);
				const base64 = imageData.toString("base64");
				comment += `<details>\n`;
				comment += `<summary>View Diff Image</summary>\n\n`;
				comment += `![Visual Diff](data:image/png;base64,${base64})\n\n`;
				comment += `</details>\n\n`;
			} catch (error) {
				comment += `_Failed to load image: ${failure.diffPath}_\n\n`;
				console.error(`Error reading image ${failure.diffPath}:`, error);
			}
		}
	}

	comment += `\n---\n`;
	comment += `_This comment was automatically generated by the visual test reporter._\n`;
	comment += `<!-- visual-test-reporter -->\n`; // Marker to identify our comments

	return comment;
}

/**
 * Minimizes previous visual test reporter comments
 */
async function minimizePreviousComments(
	owner: string,
	repo: string,
	prNumber: string,
	token: string,
) {
	const commentsUrl = `https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/comments`;

	try {
		// Fetch all comments on the PR
		const response = await fetch(commentsUrl, {
			headers: {
				Authorization: `Bearer ${token}`,
				Accept: "application/vnd.github.v3+json",
			},
		});

		if (!response.ok) {
			console.warn(`‚ö†Ô∏è  Failed to fetch existing comments: ${response.status}`);
			return;
		}

		const comments = await response.json();

		// Find comments from the visual test reporter
		const botComments = comments.filter((comment: { body?: string; node_id: string; id: number }) =>
			comment.body?.includes("<!-- visual-test-reporter -->"),
		);

		if (botComments.length === 0) {
			return;
		}

		console.log(`üîÑ Found ${botComments.length} previous visual test report(s), minimizing...`);

		// Minimize each comment using GraphQL
		for (const comment of botComments) {
			try {
				const graphqlUrl = "https://api.github.com/graphql";
				const mutation = `
					mutation {
						minimizeComment(input: {
							subjectId: "${comment.node_id}",
							classifier: OUTDATED
						}) {
							minimizedComment {
								isMinimized
							}
						}
					}
				`;

				const graphqlResponse = await fetch(graphqlUrl, {
					method: "POST",
					headers: {
						Authorization: `Bearer ${token}`,
						"Content-Type": "application/json",
					},
					body: JSON.stringify({ query: mutation }),
				});

				if (graphqlResponse.ok) {
					console.log(`‚úÖ Minimized comment #${comment.id}`);
				}
			} catch (error) {
				console.warn(`‚ö†Ô∏è  Failed to minimize comment #${comment.id}:`, error);
			}
		}
	} catch (error) {
		console.warn("‚ö†Ô∏è  Failed to minimize previous comments:", error);
	}
}

async function postGitHubComment(markdown: string) {
	const token = process.env.GITHUB_TOKEN;
	const prNumber = process.env.PR_NUMBER;
	const repository = process.env.GITHUB_REPOSITORY; // owner/repo

	if (!token || !prNumber || !repository) {
		console.log("\nüìù Local execution - would post this comment:");
		console.log("‚îÄ".repeat(80));
		console.log(markdown);
		console.log("‚îÄ".repeat(80));
		return;
	}

	const [owner, repo] = repository.split("/");

	// Minimize previous visual test reporter comments
	await minimizePreviousComments(owner, repo, prNumber, token);

	const apiUrl = `https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/comments`;

	try {
		const response = await fetch(apiUrl, {
			method: "POST",
			headers: {
				Authorization: `Bearer ${token}`,
				Accept: "application/vnd.github.v3+json",
				"Content-Type": "application/json",
			},
			body: JSON.stringify({
				body: markdown,
			}),
		});

		if (!response.ok) {
			const errorText = await response.text();
			console.error(`Failed to post comment: ${response.status} ${response.statusText}`);
			console.error(errorText);
			process.exit(1);
		}

		const result = await response.json();
		console.log(`‚úÖ Posted comment to PR #${prNumber}: ${result.html_url}`);
	} catch (error) {
		console.error("Error posting comment:", error);
		process.exit(1);
	}
}

async function main() {
	const jsonPath = "/tmp/visual-test-failures.json";

	console.log("üîç Reading visual test failures from JSON...");
	const failures = readFailuresFromJSON(jsonPath);

	if (failures.length === 0) {
		console.log("‚úÖ No visual test failures found!");
		return;
	}

	console.log(`üì∏ Found ${failures.length} failure(s)`);

	const markdown = generateMarkdownComment(failures);
	await postGitHubComment(markdown);
}

main().catch((error) => {
	console.error("Fatal error:", error);
	process.exit(1);
});
